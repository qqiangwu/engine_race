!<arch>
//                                              22        `
db_file_manager.cpp/

/0              1537701840  1000  1000  100664  273       `
#include "db_file_manager.h"

using namespace zero_switch;

DBFile_manager::DBFile_manager(DBMeta& meta)
{
}

bool DBFile_manager::read(const string_view key, std::string* value)
{
    return false;
}

void DBFile_manager::on_dump_complete(const std::uint64_t file_id)
{
}

db_meta.cpp/    1537700513  1000  1000  100664  914       `
#include <cassert>
#include "db_meta.h"

using namespace zero_switch;

DBMeta::DBMeta(const std::string& db)
    : db_(db),
      redo_id_(0),
      next_redo_id_(1),
      next_file_id_(1)
{
}

std::uint64_t DBMeta::current_redo_id() const
{
    std::lock_guard<std::mutex> lock(mutex_);

    return redo_id_;
}

std::uint64_t DBMeta::next_redo_id()
{
    std::lock_guard<std::mutex> lock(mutex_);

    return next_redo_id_++;
}

std::vector<std::uint64_t> DBMeta::sorted_tables() const
{
    std::lock_guard<std::mutex> lock(mutex_);

    return sorted_tables_;
}

void DBMeta::on_dump_complete(const std::uint64_t redo_id, const std::uint64_t file_id)
{
    std::lock_guard<std::mutex> lock(mutex_);

    assert(redo_id > redo_id_);
    assert(redo_id < next_redo_id_);

    redo_id_ = redo_id;
    sorted_tables_.push_back(file_id);

    checkpoint_();
}

void DBMeta::checkpoint_()
{
    // TODO checkpoint
}
dumper.cpp/     1537703000  1000  1000  100664  1599      `
#include <cstdio>
#include <vector>
#include <memory>
#include <system_error>
#include <cerrno>
#include "dumper.h"

using namespace zero_switch;
using namespace boost;

Dumper::Dumper()
    : executor_(1)
{
}

future<void> Dumper::submit(const Memfile& memfile, const std::uint64_t l0file)
{
    packaged_task<bool> task([this, &memfile, l0file]{
        this->run_(memfile, l0file);
        return true;
    });

    executor_.submit(task);

    return task.get_future();
}

void Dumper::run_(const Memfile& memfile, const uint64_t l0file)
{
    std::vector<std::pair<std::string*, std::string*>> table;
    table.reserve(memfile.size());

    for (auto& kv: memfile) {
        table.push_back(&kv->first, &kv->second);
    }

    std::sort(table.begin(), table.end(), [](const auto a, const auto b){
        return *a->first < *b->first;
    });

    const std::string filename = std::to_string(l0file) + ".db";
    char buffer[1 * 1024 * 1024];
    FILE* file = std::fopen(filename.c_str(), "a");
    if (!file) {
        throw std::system_error(errno);
    }

    std::setvbuf(file, buffer, _IOFBUF, sizeof(buffer));
    for (auto& x: table) {
        const auto k = x.first;
        const auto v = x.second;
        const auto rc = std::fprintf(file, "%lu%s%lu%s", unsigned(k->size()), k->data(), unsigned(v->size()), v->data());
        if (rc != k->size() + v->size() + sizeof(unsigned) * 2) {
            std::flose(file);
            throw std::system_error(errno);
        }
    }

    const auto rc = std::fclose(file);
    if (rc != 0) {
        throw std::system_error(errno);
    }
}

engine_race.cpp/1537704664  1000  1000  100664  4035      `
// Copyright [2018] Alibaba Cloud All rights reserved
#include <string_view>
#include "engine_race.h"
#include "replayer.h"

using namespace zero_switch;

namespace polar_race {

RetCode Engine::Open(const std::string& name, Engine** eptr)
{
    return EngineRace::Open(name, eptr);
}

Engine::~Engine()
{
}

/*
 * Complete the functions below to implement you own engine
 */

// 1. Open engine
RetCode EngineRace::Open(const std::string& name, Engine** eptr)
try {
    *eptr = new EngineRace(name);

    return kSucc;
} catch (const std::exception& e) {
    return kIOError;
}

EngineRace::EngineRace(const std::string& name)
    : meta_(name),
      dbfileMgr_(meta_)
{
    replay_();
    roll_new_memfile_();
}

// 2. Close engine
// TODO elegant exit
EngineRace::~EngineRace()
{
}

// 3. Write a key-value pair into engine
RetCode EngineRace::Write(const PolarString& key, const PolarString& value)
try {
    std::unique_lock<std::mutex> lock(mutex_);

    wait_for_room_(lock);
    append_log_(key, value);
    apply_(key, value);

    return kSucc;
} catch (const std::exception&) {
    return kIOError;
}

// 4. Read value of a key
RetCode EngineRace::Read(const PolarString& key, std::string* value)
try {
    if (read_memfile_(memfile_, key, value)) {
        return kSucc;
    }
    if (dbfileMgr_.read(std::string_view(key.data(), key.size()), value)) {
        return kSucc;
    }
    return kNotFound;
} catch (const std::exception& e) {
    return kIOError;
}

// 5. Applies the given Vistor::Visit function to the result
// of every key-value pair in the key range [first, last),
// in order
// lower=="" is treated as a key before all keys in the database.
// upper=="" is treated as a key after all keys in the database.
// Therefore the following call will traverse the entire database:
//   Range("", "", visitor)
RetCode EngineRace::Range(const PolarString& lower, const PolarString& upper,
    Visitor &visitor) {
  return kSucc;
}

void EngineRace::replay_()
{
    Replayer replayer(meta_, dbfileMgr_, dumper_);

    replayer.replay();
}

void EngineRace::roll_new_memfile_()
{
    memfile_ = std::make_shared<Memfile>();
    redolog_ = std::make_shared<Redo_log>(meta_.db(), meta_.next_redo_id());
}

// @pre locked
void EngineRace::wait_for_room_(std::unique_lock<std::mutex>& lock)
{
    if (memfile_->size() >= 1024) {
        while (immutable_memfile_) {
            dump_done_.wait(lock);
        }

        if (memfile_->size() >= 1024) {
            submit_memfile_(memfile_);
            roll_new_memfile_();
        }
    }
}

// @pre locked
void EngineRace::submit_memfile_(const Memfile_ptr& memfile)
{
    const auto file_id = meta_.next_id();
    const auto redo_id = redolog_->id();
    dumper_.submit(*memfile_, file_id)
        .then([this, redo_id, file_id](auto r) {
            this->on_dump_complete_(redo_id, file_id);
        });

    immutable_memfile_ = memfile_;
    memfile_ = nullptr;
    redolog_ = nullptr;
}

void EngineRace::on_dump_complete_(const uint64_t redo_id, const uint64_t file_id)
{
    // transition serialized by dumper
    meta_.on_dump_complete(redo_id, file_id);
    dbfileMgr_.on_dump_complete(file_id);

    {
        std::lock_guard<std::mutex> lock(mutex_);
        immutable_memfile_ = nullptr;
    }

    dump_done_.notify_one();
    //gc_();
}

// serialized by dumper
// TODO
void EngineRace::gc_()
{
}

void EngineRace::append_log_(const PolarString& key, const PolarString& value)
{
    auto k = std::string_view(key.data(), key.size());
    auto v = std::string_view(value.data(), value.size());
    redolog_->append(k, v);
}

void EngineRace::apply_(const PolarString& key, const PolarString& value)
{
    memfile_->emplace(key.ToString(), value.ToString());
}

bool EngineRace::read_memfile_(const Memfile_ptr& memfile, const PolarString& key, std::string* value)
{
    auto iter = memfile_->find(key.ToString());
    if (iter == memfile_->end()) {
        return false;
    }

    *value = iter->second;
    return true;
}

}  // namespace polar_race


redo_log.cpp/   1537701490  1000  1000  100664  826       `
#include <system_error>
#include <errno>
#include "redo_log.h"

using namespace zero_switch;

Redo_log::Redo_log(const std::string& dir, const std::uint64_t id)
    : dir_(dir),
      id_(id),
      out_(std::fopen((dir + '/' + std::to_string(id) + ".redo").c_str(), "a"))
{
    if (!out_) {
        throw std::system_error(errno);
    }
}

Redo_log::~Redo_log()
{
    std::fclose(out_);
    out_ = nullptr;
}

void Redo_log::append(const string_view key, const string_view value)
{
    const auto r = std::fprintf(out_, "%lu%s%lu%s",
            unsigned(key.size()), key.data(),
            unsigned(value.size()), value.data());
    if (r != key.size() + value.size() + sizeof(unsigned) * 2) {
        throw std::system_error(errno);
    }

    if (std::fflush(out_) != 0) {
        throw std::system_error(errno);
    }
}
replayer.cpp/   1537703427  1000  1000  100664  238       `
#include "core.h"
#include "replayer.h"

using namespace zero_switch;

Replayer::Replayer(DBMeta& meta, DBFile_manager& mgr, Dumper& dumper)
    : meta_(meta),
      dbfileMgr_(mgr),
      dumper_(dumper)
{
}

void Replayer::replay()
{
}
